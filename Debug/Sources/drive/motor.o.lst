   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"motor.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.clh,"aw",%nobits
  18              		.align	2
  21              	clh:
  22 0000 00000000 		.space	56
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.valueRight,"aw",%nobits
  26              	valueRight:
  27 0000 00       		.space	1
  28              		.section	.bss.valueLeft,"aw",%nobits
  31              	valueLeft:
  32 0000 00       		.space	1
  33              		.section	.text.motorIncrementPwmRight,"ax",%progbits
  34              		.align	1
  35              		.global	motorIncrementPwmRight
  36              		.syntax unified
  37              		.thumb
  38              		.thumb_func
  39              		.fpu fpv4-sp-d16
  41              	motorIncrementPwmRight:
  42              	.LFB125:
  43              		.file 1 "../Sources/drive/motor.c"
   1:../Sources/drive/motor.c **** /**
   2:../Sources/drive/motor.c ****  *--------------------------------------------------------------------\n
   3:../Sources/drive/motor.c ****  *          HSLU T&A Hochschule Luzern Technik+Architektur            \n
   4:../Sources/drive/motor.c ****  *--------------------------------------------------------------------\n
   5:../Sources/drive/motor.c ****  *
   6:../Sources/drive/motor.c ****  * \brief         motor driver
   7:../Sources/drive/motor.c ****  * \file
   8:../Sources/drive/motor.c ****  * \author        Christian Jost, christian.jost@hslu.ch
   9:../Sources/drive/motor.c ****  * \date          03.04.20018
  10:../Sources/drive/motor.c ****  *
  11:../Sources/drive/motor.c ****  * $Id: motor.c 91 2018-04-20 07:20:56Z zajost $
  12:../Sources/drive/motor.c ****  *
  13:../Sources/drive/motor.c ****  *--------------------------------------------------------------------
  14:../Sources/drive/motor.c ****  */
  15:../Sources/drive/motor.c **** 
  16:../Sources/drive/motor.c **** #include "platform.h"
  17:../Sources/drive/motor.c **** #include "motor.h"
  18:../Sources/drive/motor.c **** #include "ftm3.h"
  19:../Sources/drive/motor.c **** #include "term.h"
  20:../Sources/drive/motor.c **** #include "util.h"
  21:../Sources/drive/motor.c **** #include <string.h>
  22:../Sources/drive/motor.c **** #if !SOLUTION
  23:../Sources/drive/motor.c **** 
  24:../Sources/drive/motor.c **** // todo #9.04 complete the macros to switch a pin configuration from GPIO to FTM-Mode and vice vers
  25:../Sources/drive/motor.c **** #define MOTOR_RIGHT_A_PWM()           (PORTD_PCR0 = PORT_PCR_MUX(4))  // PTD0: FTM3_CH0
  26:../Sources/drive/motor.c **** #define MOTOR_RIGHT_A_GPIO()          (PORTD_PCR0 = PORT_PCR_MUX(1))  // PTD0: GPIO
  27:../Sources/drive/motor.c **** #define MOTOR_RIGHT_B_PWM()           (PORTE_PCR5 = PORT_PCR_MUX(6))  // PTE5: FTM3_CH0
  28:../Sources/drive/motor.c **** #define MOTOR_RIGHT_B_GPIO()          (PORTE_PCR5 = PORT_PCR_MUX(1))  // PTE5: GPIO
  29:../Sources/drive/motor.c **** 
  30:../Sources/drive/motor.c **** #define MOTOR_LEFT_A_PWM()            (PORTD_PCR1 = PORT_PCR_MUX(4))  // PTD1: FTM3_CH1
  31:../Sources/drive/motor.c **** #define MOTOR_LEFT_A_GPIO()           (PORTD_PCR1 = PORT_PCR_MUX(1))  // PTD1: GPIO
  32:../Sources/drive/motor.c **** #define MOTOR_LEFT_B_PWM()            (PORTE_PCR6 = PORT_PCR_MUX(6))  // PTE6: FTM3_CH1
  33:../Sources/drive/motor.c **** #define MOTOR_LEFT_B_GPIO()           (PORTE_PCR6 = PORT_PCR_MUX(1))  // PTE6: GPIO
  34:../Sources/drive/motor.c **** 
  35:../Sources/drive/motor.c **** static tCommandLineHandler clh;       // terminal command line handler
  36:../Sources/drive/motor.c **** static int8_t valueRight;
  37:../Sources/drive/motor.c **** static int8_t valueLeft;
  38:../Sources/drive/motor.c **** 
  39:../Sources/drive/motor.c **** 
  40:../Sources/drive/motor.c **** 
  41:../Sources/drive/motor.c **** /**
  42:../Sources/drive/motor.c ****  * Increments or decrements the PWM value oft the right wheel
  43:../Sources/drive/motor.c ****  * @param[in] value
  44:../Sources/drive/motor.c ****  *   a positive or negative value to add
  45:../Sources/drive/motor.c ****  */
  46:../Sources/drive/motor.c **** void motorIncrementPwmRight(int8_t value)
  47:../Sources/drive/motor.c **** {
  44              		.loc 1 47 0
  45              		.cfi_startproc
  46              		@ args = 0, pretend = 0, frame = 16
  47              		@ frame_needed = 1, uses_anonymous_args = 0
  48 0000 80B5     		push	{r7, lr}
  49              		.cfi_def_cfa_offset 8
  50              		.cfi_offset 7, -8
  51              		.cfi_offset 14, -4
  52 0002 84B0     		sub	sp, sp, #16
  53              		.cfi_def_cfa_offset 24
  54 0004 00AF     		add	r7, sp, #0
  55              		.cfi_def_cfa_register 7
  56 0006 0346     		mov	r3, r0
  57 0008 FB71     		strb	r3, [r7, #7]
  48:../Sources/drive/motor.c ****   int32_t v = valueRight + value;
  58              		.loc 1 48 0
  59 000a 0E4B     		ldr	r3, .L4
  60 000c 93F90030 		ldrsb	r3, [r3]
  61 0010 1A46     		mov	r2, r3
  62 0012 97F90730 		ldrsb	r3, [r7, #7]
  63 0016 1344     		add	r3, r3, r2
  64 0018 FB60     		str	r3, [r7, #12]
  49:../Sources/drive/motor.c ****   if (v > MOTOR_MAX_VALUE) v = MOTOR_MAX_VALUE;
  65              		.loc 1 49 0
  66 001a FB68     		ldr	r3, [r7, #12]
  67 001c 7F2B     		cmp	r3, #127
  68 001e 01DD     		ble	.L2
  69              		.loc 1 49 0 is_stmt 0 discriminator 1
  70 0020 7F23     		movs	r3, #127
  71 0022 FB60     		str	r3, [r7, #12]
  72              	.L2:
  50:../Sources/drive/motor.c ****   if (v < -MOTOR_MAX_VALUE) v = -MOTOR_MAX_VALUE;
  73              		.loc 1 50 0 is_stmt 1
  74 0024 FB68     		ldr	r3, [r7, #12]
  75 0026 13F17F0F 		cmn	r3, #127
  76 002a 02DA     		bge	.L3
  77              		.loc 1 50 0 is_stmt 0 discriminator 1
  78 002c 6FF07E03 		mvn	r3, #126
  79 0030 FB60     		str	r3, [r7, #12]
  80              	.L3:
  51:../Sources/drive/motor.c ****   motorSetPwmRight((int8_t)v);
  81              		.loc 1 51 0 is_stmt 1
  82 0032 FB68     		ldr	r3, [r7, #12]
  83 0034 5BB2     		sxtb	r3, r3
  84 0036 1846     		mov	r0, r3
  85 0038 FFF7FEFF 		bl	motorSetPwmRight
  52:../Sources/drive/motor.c **** }
  86              		.loc 1 52 0
  87 003c 00BF     		nop
  88 003e 1037     		adds	r7, r7, #16
  89              		.cfi_def_cfa_offset 8
  90 0040 BD46     		mov	sp, r7
  91              		.cfi_def_cfa_register 13
  92              		@ sp needed
  93 0042 80BD     		pop	{r7, pc}
  94              	.L5:
  95              		.align	2
  96              	.L4:
  97 0044 00000000 		.word	valueRight
  98              		.cfi_endproc
  99              	.LFE125:
 101              		.section	.text.motorIncrementPwmLeft,"ax",%progbits
 102              		.align	1
 103              		.global	motorIncrementPwmLeft
 104              		.syntax unified
 105              		.thumb
 106              		.thumb_func
 107              		.fpu fpv4-sp-d16
 109              	motorIncrementPwmLeft:
 110              	.LFB126:
  53:../Sources/drive/motor.c **** 
  54:../Sources/drive/motor.c **** 
  55:../Sources/drive/motor.c **** /**
  56:../Sources/drive/motor.c ****  * Increments or decrements the PWM value oft the left wheel
  57:../Sources/drive/motor.c ****  * @param[in] value
  58:../Sources/drive/motor.c ****  *   a positive or negative value to add
  59:../Sources/drive/motor.c ****  */
  60:../Sources/drive/motor.c **** void motorIncrementPwmLeft(int8_t value)
  61:../Sources/drive/motor.c **** {
 111              		.loc 1 61 0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 16
 114              		@ frame_needed = 1, uses_anonymous_args = 0
 115 0000 80B5     		push	{r7, lr}
 116              		.cfi_def_cfa_offset 8
 117              		.cfi_offset 7, -8
 118              		.cfi_offset 14, -4
 119 0002 84B0     		sub	sp, sp, #16
 120              		.cfi_def_cfa_offset 24
 121 0004 00AF     		add	r7, sp, #0
 122              		.cfi_def_cfa_register 7
 123 0006 0346     		mov	r3, r0
 124 0008 FB71     		strb	r3, [r7, #7]
  62:../Sources/drive/motor.c ****   int32_t v = valueLeft + value;
 125              		.loc 1 62 0
 126 000a 0E4B     		ldr	r3, .L9
 127 000c 93F90030 		ldrsb	r3, [r3]
 128 0010 1A46     		mov	r2, r3
 129 0012 97F90730 		ldrsb	r3, [r7, #7]
 130 0016 1344     		add	r3, r3, r2
 131 0018 FB60     		str	r3, [r7, #12]
  63:../Sources/drive/motor.c ****   if (v > MOTOR_MAX_VALUE) v = MOTOR_MAX_VALUE;
 132              		.loc 1 63 0
 133 001a FB68     		ldr	r3, [r7, #12]
 134 001c 7F2B     		cmp	r3, #127
 135 001e 01DD     		ble	.L7
 136              		.loc 1 63 0 is_stmt 0 discriminator 1
 137 0020 7F23     		movs	r3, #127
 138 0022 FB60     		str	r3, [r7, #12]
 139              	.L7:
  64:../Sources/drive/motor.c ****   if (v < -MOTOR_MAX_VALUE) v = -MOTOR_MAX_VALUE;
 140              		.loc 1 64 0 is_stmt 1
 141 0024 FB68     		ldr	r3, [r7, #12]
 142 0026 13F17F0F 		cmn	r3, #127
 143 002a 02DA     		bge	.L8
 144              		.loc 1 64 0 is_stmt 0 discriminator 1
 145 002c 6FF07E03 		mvn	r3, #126
 146 0030 FB60     		str	r3, [r7, #12]
 147              	.L8:
  65:../Sources/drive/motor.c ****   motorSetPwmLeft((int8_t)v);
 148              		.loc 1 65 0 is_stmt 1
 149 0032 FB68     		ldr	r3, [r7, #12]
 150 0034 5BB2     		sxtb	r3, r3
 151 0036 1846     		mov	r0, r3
 152 0038 FFF7FEFF 		bl	motorSetPwmLeft
  66:../Sources/drive/motor.c **** }
 153              		.loc 1 66 0
 154 003c 00BF     		nop
 155 003e 1037     		adds	r7, r7, #16
 156              		.cfi_def_cfa_offset 8
 157 0040 BD46     		mov	sp, r7
 158              		.cfi_def_cfa_register 13
 159              		@ sp needed
 160 0042 80BD     		pop	{r7, pc}
 161              	.L10:
 162              		.align	2
 163              	.L9:
 164 0044 00000000 		.word	valueLeft
 165              		.cfi_endproc
 166              	.LFE126:
 168              		.section	.text.motorSetPwmRight,"ax",%progbits
 169              		.align	1
 170              		.global	motorSetPwmRight
 171              		.syntax unified
 172              		.thumb
 173              		.thumb_func
 174              		.fpu fpv4-sp-d16
 176              	motorSetPwmRight:
 177              	.LFB127:
  67:../Sources/drive/motor.c **** 
  68:../Sources/drive/motor.c **** 
  69:../Sources/drive/motor.c **** /**
  70:../Sources/drive/motor.c ****  * Sets the PWM value of the right wheel
  71:../Sources/drive/motor.c ****  *
  72:../Sources/drive/motor.c ****  * @param[in] value
  73:../Sources/drive/motor.c ****  *   the value between -MOTOR_MAX_VALUE..0..+MOTOR_MAX_VALUE
  74:../Sources/drive/motor.c ****  *   A value of '0' stops the wheel.
  75:../Sources/drive/motor.c ****  */
  76:../Sources/drive/motor.c **** void motorSetPwmRight(int8_t value)
  77:../Sources/drive/motor.c **** {
 178              		.loc 1 77 0
 179              		.cfi_startproc
 180              		@ args = 0, pretend = 0, frame = 16
 181              		@ frame_needed = 1, uses_anonymous_args = 0
 182              		@ link register save eliminated.
 183 0000 80B4     		push	{r7}
 184              		.cfi_def_cfa_offset 4
 185              		.cfi_offset 7, -4
 186 0002 85B0     		sub	sp, sp, #20
 187              		.cfi_def_cfa_offset 24
 188 0004 00AF     		add	r7, sp, #0
 189              		.cfi_def_cfa_register 7
 190 0006 0346     		mov	r3, r0
 191 0008 FB71     		strb	r3, [r7, #7]
  78:../Sources/drive/motor.c ****   if (value > MOTOR_MAX_VALUE) value = MOTOR_MAX_VALUE;
  79:../Sources/drive/motor.c ****   if (value < -MOTOR_MAX_VALUE) value = -MOTOR_MAX_VALUE;
 192              		.loc 1 79 0
 193 000a 97F90730 		ldrsb	r3, [r7, #7]
 194 000e 13F1800F 		cmn	r3, #128
 195 0012 01D1     		bne	.L12
 196              		.loc 1 79 0 is_stmt 0 discriminator 1
 197 0014 8123     		movs	r3, #129
 198 0016 FB71     		strb	r3, [r7, #7]
 199              	.L12:
  80:../Sources/drive/motor.c ****   valueRight = value;
 200              		.loc 1 80 0 is_stmt 1
 201 0018 1B4A     		ldr	r2, .L16
 202 001a FB79     		ldrb	r3, [r7, #7]
 203 001c 1370     		strb	r3, [r2]
  81:../Sources/drive/motor.c **** 
  82:../Sources/drive/motor.c ****   if (value < 0)
 204              		.loc 1 82 0
 205 001e 97F90730 		ldrsb	r3, [r7, #7]
 206 0022 002B     		cmp	r3, #0
 207 0024 0CDA     		bge	.L13
  83:../Sources/drive/motor.c ****   {
  84:../Sources/drive/motor.c ****     // drive backward
  85:../Sources/drive/motor.c ****     value = -value;             // value has to be a positive channel value!
 208              		.loc 1 85 0
 209 0026 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 210 0028 5B42     		negs	r3, r3
 211 002a DBB2     		uxtb	r3, r3
 212 002c FB71     		strb	r3, [r7, #7]
  86:../Sources/drive/motor.c ****     MOTOR_RIGHT_A_GPIO();       // set motor right A as GPIO Pin (high-level)
 213              		.loc 1 86 0
 214 002e 174B     		ldr	r3, .L16+4
 215 0030 4FF48072 		mov	r2, #256
 216 0034 1A60     		str	r2, [r3]
  87:../Sources/drive/motor.c ****     MOTOR_RIGHT_B_PWM();        // set motor right B as timer Pin (pwm signal)
 217              		.loc 1 87 0
 218 0036 164B     		ldr	r3, .L16+8
 219 0038 4FF4C062 		mov	r2, #1536
 220 003c 5A61     		str	r2, [r3, #20]
 221 003e 0EE0     		b	.L14
 222              	.L13:
  88:../Sources/drive/motor.c ****   }
  89:../Sources/drive/motor.c ****   else if (value > 0)
 223              		.loc 1 89 0
 224 0040 97F90730 		ldrsb	r3, [r7, #7]
 225 0044 002B     		cmp	r3, #0
 226 0046 08DD     		ble	.L15
  90:../Sources/drive/motor.c ****   {
  91:../Sources/drive/motor.c ****     // drive forward
  92:../Sources/drive/motor.c ****     // todo #9.08 complete the else-if statement
  93:../Sources/drive/motor.c ****     MOTOR_RIGHT_B_GPIO();       // set motor right B as GPIO Pin (high-level)
 227              		.loc 1 93 0
 228 0048 114B     		ldr	r3, .L16+8
 229 004a 4FF48072 		mov	r2, #256
 230 004e 5A61     		str	r2, [r3, #20]
  94:../Sources/drive/motor.c ****     MOTOR_RIGHT_A_PWM();        // set motor right A as timer Pin (pwm signal)
 231              		.loc 1 94 0
 232 0050 0E4B     		ldr	r3, .L16+4
 233 0052 4FF48062 		mov	r2, #1024
 234 0056 1A60     		str	r2, [r3]
 235 0058 01E0     		b	.L14
 236              	.L15:
  95:../Sources/drive/motor.c ****   }
  96:../Sources/drive/motor.c ****   else
  97:../Sources/drive/motor.c ****   {
  98:../Sources/drive/motor.c ****     // stop
  99:../Sources/drive/motor.c ****     // todo #9.09 complete the else statement
 100:../Sources/drive/motor.c ****     value=0;
 237              		.loc 1 100 0
 238 005a 0023     		movs	r3, #0
 239 005c FB71     		strb	r3, [r7, #7]
 240              	.L14:
 101:../Sources/drive/motor.c **** 
 102:../Sources/drive/motor.c ****   }
 103:../Sources/drive/motor.c ****   int16_t v = (uint16_t)(((FTM3_MODULO + 1) * ((uint32_t)value)) / MOTOR_MAX_VALUE);
 241              		.loc 1 103 0
 242 005e 97F90730 		ldrsb	r3, [r7, #7]
 243 0062 1A03     		lsls	r2, r3, #12
 244 0064 0B4B     		ldr	r3, .L16+12
 245 0066 A3FB0213 		umull	r1, r3, r3, r2
 246 006a D21A     		subs	r2, r2, r3
 247 006c 5208     		lsrs	r2, r2, #1
 248 006e 1344     		add	r3, r3, r2
 249 0070 9B09     		lsrs	r3, r3, #6
 250 0072 FB81     		strh	r3, [r7, #14]	@ movhi
 104:../Sources/drive/motor.c ****   FTM3_C0V = v;
 251              		.loc 1 104 0
 252 0074 084A     		ldr	r2, .L16+16
 253 0076 B7F90E30 		ldrsh	r3, [r7, #14]
 254 007a 1361     		str	r3, [r2, #16]
 105:../Sources/drive/motor.c **** }
 255              		.loc 1 105 0
 256 007c 00BF     		nop
 257 007e 1437     		adds	r7, r7, #20
 258              		.cfi_def_cfa_offset 4
 259 0080 BD46     		mov	sp, r7
 260              		.cfi_def_cfa_register 13
 261              		@ sp needed
 262 0082 5DF8047B 		ldr	r7, [sp], #4
 263              		.cfi_restore 7
 264              		.cfi_def_cfa_offset 0
 265 0086 7047     		bx	lr
 266              	.L17:
 267              		.align	2
 268              	.L16:
 269 0088 00000000 		.word	valueRight
 270 008c 00C00440 		.word	1074053120
 271 0090 00D00440 		.word	1074057216
 272 0094 11080402 		.word	33818641
 273 0098 00600240 		.word	1073897472
 274              		.cfi_endproc
 275              	.LFE127:
 277              		.section	.text.motorSetPwmLeft,"ax",%progbits
 278              		.align	1
 279              		.global	motorSetPwmLeft
 280              		.syntax unified
 281              		.thumb
 282              		.thumb_func
 283              		.fpu fpv4-sp-d16
 285              	motorSetPwmLeft:
 286              	.LFB128:
 106:../Sources/drive/motor.c **** 
 107:../Sources/drive/motor.c **** 
 108:../Sources/drive/motor.c **** /**
 109:../Sources/drive/motor.c ****  * Sets the PWM value of the left wheel
 110:../Sources/drive/motor.c ****  *
 111:../Sources/drive/motor.c ****  * @param[in] value
 112:../Sources/drive/motor.c ****  *   the value between -MOTOR_MAX_VALUE..0..+MOTOR_MAX_VALUE
 113:../Sources/drive/motor.c ****  *   A value of '0' stops the wheel.
 114:../Sources/drive/motor.c ****  */
 115:../Sources/drive/motor.c **** void motorSetPwmLeft(int8_t value)
 116:../Sources/drive/motor.c **** {
 287              		.loc 1 116 0
 288              		.cfi_startproc
 289              		@ args = 0, pretend = 0, frame = 16
 290              		@ frame_needed = 1, uses_anonymous_args = 0
 291              		@ link register save eliminated.
 292 0000 80B4     		push	{r7}
 293              		.cfi_def_cfa_offset 4
 294              		.cfi_offset 7, -4
 295 0002 85B0     		sub	sp, sp, #20
 296              		.cfi_def_cfa_offset 24
 297 0004 00AF     		add	r7, sp, #0
 298              		.cfi_def_cfa_register 7
 299 0006 0346     		mov	r3, r0
 300 0008 FB71     		strb	r3, [r7, #7]
 117:../Sources/drive/motor.c ****   // todo #9.10 complete the function as above
 118:../Sources/drive/motor.c ****   if (value > MOTOR_MAX_VALUE) value = MOTOR_MAX_VALUE;
 119:../Sources/drive/motor.c ****     if (value < -MOTOR_MAX_VALUE) value = -MOTOR_MAX_VALUE;
 301              		.loc 1 119 0
 302 000a 97F90730 		ldrsb	r3, [r7, #7]
 303 000e 13F1800F 		cmn	r3, #128
 304 0012 01D1     		bne	.L19
 305              		.loc 1 119 0 is_stmt 0 discriminator 1
 306 0014 8123     		movs	r3, #129
 307 0016 FB71     		strb	r3, [r7, #7]
 308              	.L19:
 120:../Sources/drive/motor.c ****     valueLeft = value;
 309              		.loc 1 120 0 is_stmt 1
 310 0018 1B4A     		ldr	r2, .L23
 311 001a FB79     		ldrb	r3, [r7, #7]
 312 001c 1370     		strb	r3, [r2]
 121:../Sources/drive/motor.c **** 
 122:../Sources/drive/motor.c ****     if (value < 0)
 313              		.loc 1 122 0
 314 001e 97F90730 		ldrsb	r3, [r7, #7]
 315 0022 002B     		cmp	r3, #0
 316 0024 0CDA     		bge	.L20
 123:../Sources/drive/motor.c ****     {
 124:../Sources/drive/motor.c ****       // drive backward
 125:../Sources/drive/motor.c ****       value = -value;             // value has to be a positive channel value!
 317              		.loc 1 125 0
 318 0026 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 319 0028 5B42     		negs	r3, r3
 320 002a DBB2     		uxtb	r3, r3
 321 002c FB71     		strb	r3, [r7, #7]
 126:../Sources/drive/motor.c ****       MOTOR_LEFT_B_GPIO();       // set motor right A as GPIO Pin (high-level)
 322              		.loc 1 126 0
 323 002e 174B     		ldr	r3, .L23+4
 324 0030 4FF48072 		mov	r2, #256
 325 0034 9A61     		str	r2, [r3, #24]
 127:../Sources/drive/motor.c ****       MOTOR_LEFT_A_PWM();        // set motor right B as timer Pin (pwm signal)
 326              		.loc 1 127 0
 327 0036 164B     		ldr	r3, .L23+8
 328 0038 4FF48062 		mov	r2, #1024
 329 003c 5A60     		str	r2, [r3, #4]
 330 003e 0EE0     		b	.L21
 331              	.L20:
 128:../Sources/drive/motor.c ****     }
 129:../Sources/drive/motor.c ****     else if (value > 0)
 332              		.loc 1 129 0
 333 0040 97F90730 		ldrsb	r3, [r7, #7]
 334 0044 002B     		cmp	r3, #0
 335 0046 08DD     		ble	.L22
 130:../Sources/drive/motor.c ****     {
 131:../Sources/drive/motor.c ****       // drive forward
 132:../Sources/drive/motor.c ****       MOTOR_LEFT_A_GPIO();       // set motor right A as GPIO Pin (high-level)
 336              		.loc 1 132 0
 337 0048 114B     		ldr	r3, .L23+8
 338 004a 4FF48072 		mov	r2, #256
 339 004e 5A60     		str	r2, [r3, #4]
 133:../Sources/drive/motor.c ****       MOTOR_LEFT_B_PWM();
 340              		.loc 1 133 0
 341 0050 0E4B     		ldr	r3, .L23+4
 342 0052 4FF4C062 		mov	r2, #1536
 343 0056 9A61     		str	r2, [r3, #24]
 344 0058 01E0     		b	.L21
 345              	.L22:
 134:../Sources/drive/motor.c **** 
 135:../Sources/drive/motor.c ****     }
 136:../Sources/drive/motor.c ****     else
 137:../Sources/drive/motor.c ****     {
 138:../Sources/drive/motor.c ****       // stop
 139:../Sources/drive/motor.c ****       value=0;
 346              		.loc 1 139 0
 347 005a 0023     		movs	r3, #0
 348 005c FB71     		strb	r3, [r7, #7]
 349              	.L21:
 140:../Sources/drive/motor.c **** 
 141:../Sources/drive/motor.c ****     }
 142:../Sources/drive/motor.c ****     int16_t v = (uint16_t)(((FTM3_MODULO + 1) * ((uint32_t)value)) / MOTOR_MAX_VALUE);
 350              		.loc 1 142 0
 351 005e 97F90730 		ldrsb	r3, [r7, #7]
 352 0062 1A03     		lsls	r2, r3, #12
 353 0064 0B4B     		ldr	r3, .L23+12
 354 0066 A3FB0213 		umull	r1, r3, r3, r2
 355 006a D21A     		subs	r2, r2, r3
 356 006c 5208     		lsrs	r2, r2, #1
 357 006e 1344     		add	r3, r3, r2
 358 0070 9B09     		lsrs	r3, r3, #6
 359 0072 FB81     		strh	r3, [r7, #14]	@ movhi
 143:../Sources/drive/motor.c ****     FTM3_C1V = v;
 360              		.loc 1 143 0
 361 0074 084A     		ldr	r2, .L23+16
 362 0076 B7F90E30 		ldrsh	r3, [r7, #14]
 363 007a 9361     		str	r3, [r2, #24]
 144:../Sources/drive/motor.c **** 
 145:../Sources/drive/motor.c **** 
 146:../Sources/drive/motor.c **** 
 147:../Sources/drive/motor.c **** }
 364              		.loc 1 147 0
 365 007c 00BF     		nop
 366 007e 1437     		adds	r7, r7, #20
 367              		.cfi_def_cfa_offset 4
 368 0080 BD46     		mov	sp, r7
 369              		.cfi_def_cfa_register 13
 370              		@ sp needed
 371 0082 5DF8047B 		ldr	r7, [sp], #4
 372              		.cfi_restore 7
 373              		.cfi_def_cfa_offset 0
 374 0086 7047     		bx	lr
 375              	.L24:
 376              		.align	2
 377              	.L23:
 378 0088 00000000 		.word	valueLeft
 379 008c 00D00440 		.word	1074057216
 380 0090 00C00440 		.word	1074053120
 381 0094 11080402 		.word	33818641
 382 0098 00600240 		.word	1073897472
 383              		.cfi_endproc
 384              	.LFE128:
 386              		.section	.rodata
 387              		.align	2
 388              	.LC0:
 389 0000 68656C70 		.ascii	"help\000"
 389      00
 390 0005 000000   		.align	2
 391              	.LC1:
 392 0008 6D6F7420 		.ascii	"mot (motor) commands:\000"
 392      286D6F74 
 392      6F722920 
 392      636F6D6D 
 392      616E6473 
 393 001e 0000     		.align	2
 394              	.LC2:
 395 0020 20206865 		.ascii	"  help\000"
 395      6C7000
 396 0027 00       		.align	2
 397              	.LC3:
 398 0028 20207365 		.ascii	"  setL [-100..100]\000"
 398      744C205B 
 398      2D313030 
 398      2E2E3130 
 398      305D00
 399 003b 00       		.align	2
 400              	.LC4:
 401 003c 20207365 		.ascii	"  setR [-100..100]\000"
 401      7452205B 
 401      2D313030 
 401      2E2E3130 
 401      305D00
 402 004f 00       		.align	2
 403              	.LC5:
 404 0050 20207374 		.ascii	"  status\000"
 404      61747573 
 404      00
 405 0059 000000   		.align	2
 406              	.LC6:
 407 005c 7365744C 		.ascii	"setL\000"
 407      00
 408 0061 000000   		.align	2
 409              	.LC7:
 410 0064 73657452 		.ascii	"setR\000"
 410      00
 411              		.section	.text.motorParseCommand,"ax",%progbits
 412              		.align	1
 413              		.global	motorParseCommand
 414              		.syntax unified
 415              		.thumb
 416              		.thumb_func
 417              		.fpu fpv4-sp-d16
 419              	motorParseCommand:
 420              	.LFB129:
 148:../Sources/drive/motor.c **** 
 149:../Sources/drive/motor.c **** 
 150:../Sources/drive/motor.c **** /**
 151:../Sources/drive/motor.c ****  * Command line parser for this file.
 152:../Sources/drive/motor.c ****  * This code is complete and works.
 153:../Sources/drive/motor.c ****  *
 154:../Sources/drive/motor.c ****  * @param[in] cmd
 155:../Sources/drive/motor.c ****  *   the command to parse
 156:../Sources/drive/motor.c ****  */
 157:../Sources/drive/motor.c **** tError motorParseCommand(const unsigned char *cmd)
 158:../Sources/drive/motor.c **** {
 421              		.loc 1 158 0
 422              		.cfi_startproc
 423              		@ args = 0, pretend = 0, frame = 16
 424              		@ frame_needed = 1, uses_anonymous_args = 0
 425 0000 80B5     		push	{r7, lr}
 426              		.cfi_def_cfa_offset 8
 427              		.cfi_offset 7, -8
 428              		.cfi_offset 14, -4
 429 0002 84B0     		sub	sp, sp, #16
 430              		.cfi_def_cfa_offset 24
 431 0004 00AF     		add	r7, sp, #0
 432              		.cfi_def_cfa_register 7
 433 0006 7860     		str	r0, [r7, #4]
 159:../Sources/drive/motor.c ****   tError result = EC_INVALID_ARG;
 434              		.loc 1 159 0
 435 0008 0223     		movs	r3, #2
 436 000a FB73     		strb	r3, [r7, #15]
 160:../Sources/drive/motor.c ****   if (strcmp(cmd, "help") == 0)
 437              		.loc 1 160 0
 438 000c 7B68     		ldr	r3, [r7, #4]
 439 000e 3949     		ldr	r1, .L32
 440 0010 1846     		mov	r0, r3
 441 0012 FFF7FEFF 		bl	strcmp
 442 0016 0346     		mov	r3, r0
 443 0018 002B     		cmp	r3, #0
 444 001a 11D1     		bne	.L26
 161:../Sources/drive/motor.c ****   {
 162:../Sources/drive/motor.c ****     termWriteLine("mot (motor) commands:");
 445              		.loc 1 162 0
 446 001c 3648     		ldr	r0, .L32+4
 447 001e FFF7FEFF 		bl	termWriteLine
 163:../Sources/drive/motor.c ****     termWriteLine("  help");
 448              		.loc 1 163 0
 449 0022 3648     		ldr	r0, .L32+8
 450 0024 FFF7FEFF 		bl	termWriteLine
 164:../Sources/drive/motor.c ****     termWriteLine("  setL [-100..100]");
 451              		.loc 1 164 0
 452 0028 3548     		ldr	r0, .L32+12
 453 002a FFF7FEFF 		bl	termWriteLine
 165:../Sources/drive/motor.c ****     termWriteLine("  setR [-100..100]");
 454              		.loc 1 165 0
 455 002e 3548     		ldr	r0, .L32+16
 456 0030 FFF7FEFF 		bl	termWriteLine
 166:../Sources/drive/motor.c ****     termWriteLine("  status");
 457              		.loc 1 166 0
 458 0034 3448     		ldr	r0, .L32+20
 459 0036 FFF7FEFF 		bl	termWriteLine
 167:../Sources/drive/motor.c ****     result = EC_SUCCESS;
 460              		.loc 1 167 0
 461 003a 0023     		movs	r3, #0
 462 003c FB73     		strb	r3, [r7, #15]
 463 003e 54E0     		b	.L27
 464              	.L26:
 168:../Sources/drive/motor.c ****   }
 169:../Sources/drive/motor.c ****   else if (strncmp(cmd, "setL", sizeof("setL")-1) == 0)
 465              		.loc 1 169 0
 466 0040 7B68     		ldr	r3, [r7, #4]
 467 0042 0422     		movs	r2, #4
 468 0044 3149     		ldr	r1, .L32+24
 469 0046 1846     		mov	r0, r3
 470 0048 FFF7FEFF 		bl	strncmp
 471 004c 0346     		mov	r3, r0
 472 004e 002B     		cmp	r3, #0
 473 0050 21D1     		bne	.L28
 474              	.LBB2:
 170:../Sources/drive/motor.c ****   {
 171:../Sources/drive/motor.c ****     cmd += sizeof("setL");
 475              		.loc 1 171 0
 476 0052 7B68     		ldr	r3, [r7, #4]
 477 0054 0533     		adds	r3, r3, #5
 478 0056 7B60     		str	r3, [r7, #4]
 172:../Sources/drive/motor.c ****     int16_t v;
 173:../Sources/drive/motor.c ****     result = utilScanDecimal16s(&cmd, &v);
 479              		.loc 1 173 0
 480 0058 07F10C02 		add	r2, r7, #12
 481 005c 3B1D     		adds	r3, r7, #4
 482 005e 1146     		mov	r1, r2
 483 0060 1846     		mov	r0, r3
 484 0062 FFF7FEFF 		bl	utilScanDecimal16s
 485 0066 0346     		mov	r3, r0
 486 0068 FB73     		strb	r3, [r7, #15]
 174:../Sources/drive/motor.c ****     if (result != EC_SUCCESS) return result;
 487              		.loc 1 174 0
 488 006a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 489 006c 002B     		cmp	r3, #0
 490 006e 01D0     		beq	.L29
 491              		.loc 1 174 0 is_stmt 0 discriminator 1
 492 0070 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 493 0072 3BE0     		b	.L30
 494              	.L29:
 175:../Sources/drive/motor.c ****     motorSetPwmLeft((int16_t)((MOTOR_MAX_VALUE * v) / 100));
 495              		.loc 1 175 0 is_stmt 1
 496 0074 B7F90C30 		ldrsh	r3, [r7, #12]
 497 0078 1A46     		mov	r2, r3
 498 007a 1346     		mov	r3, r2
 499 007c DB01     		lsls	r3, r3, #7
 500 007e 9B1A     		subs	r3, r3, r2
 501 0080 234A     		ldr	r2, .L32+28
 502 0082 82FB0312 		smull	r1, r2, r2, r3
 503 0086 5211     		asrs	r2, r2, #5
 504 0088 DB17     		asrs	r3, r3, #31
 505 008a D31A     		subs	r3, r2, r3
 506 008c 5BB2     		sxtb	r3, r3
 507 008e 1846     		mov	r0, r3
 508 0090 FFF7FEFF 		bl	motorSetPwmLeft
 509              	.LBE2:
 510 0094 29E0     		b	.L27
 511              	.L28:
 176:../Sources/drive/motor.c ****   }
 177:../Sources/drive/motor.c ****   else if (strncmp(cmd, "setR", sizeof("setR")-1) == 0)
 512              		.loc 1 177 0
 513 0096 7B68     		ldr	r3, [r7, #4]
 514 0098 0422     		movs	r2, #4
 515 009a 1E49     		ldr	r1, .L32+32
 516 009c 1846     		mov	r0, r3
 517 009e FFF7FEFF 		bl	strncmp
 518 00a2 0346     		mov	r3, r0
 519 00a4 002B     		cmp	r3, #0
 520 00a6 20D1     		bne	.L27
 521              	.LBB3:
 178:../Sources/drive/motor.c ****   {
 179:../Sources/drive/motor.c ****     cmd += sizeof("setR");
 522              		.loc 1 179 0
 523 00a8 7B68     		ldr	r3, [r7, #4]
 524 00aa 0533     		adds	r3, r3, #5
 525 00ac 7B60     		str	r3, [r7, #4]
 180:../Sources/drive/motor.c ****     int16_t v;
 181:../Sources/drive/motor.c ****     result = utilScanDecimal16s(&cmd, &v);
 526              		.loc 1 181 0
 527 00ae 07F10A02 		add	r2, r7, #10
 528 00b2 3B1D     		adds	r3, r7, #4
 529 00b4 1146     		mov	r1, r2
 530 00b6 1846     		mov	r0, r3
 531 00b8 FFF7FEFF 		bl	utilScanDecimal16s
 532 00bc 0346     		mov	r3, r0
 533 00be FB73     		strb	r3, [r7, #15]
 182:../Sources/drive/motor.c ****     if (result != EC_SUCCESS) return result;
 534              		.loc 1 182 0
 535 00c0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 536 00c2 002B     		cmp	r3, #0
 537 00c4 01D0     		beq	.L31
 538              		.loc 1 182 0 is_stmt 0 discriminator 1
 539 00c6 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 540 00c8 10E0     		b	.L30
 541              	.L31:
 183:../Sources/drive/motor.c ****     motorSetPwmRight((int16_t)((MOTOR_MAX_VALUE * v) / 100));
 542              		.loc 1 183 0 is_stmt 1
 543 00ca B7F90A30 		ldrsh	r3, [r7, #10]
 544 00ce 1A46     		mov	r2, r3
 545 00d0 1346     		mov	r3, r2
 546 00d2 DB01     		lsls	r3, r3, #7
 547 00d4 9B1A     		subs	r3, r3, r2
 548 00d6 0E4A     		ldr	r2, .L32+28
 549 00d8 82FB0312 		smull	r1, r2, r2, r3
 550 00dc 5211     		asrs	r2, r2, #5
 551 00de DB17     		asrs	r3, r3, #31
 552 00e0 D31A     		subs	r3, r2, r3
 553 00e2 5BB2     		sxtb	r3, r3
 554 00e4 1846     		mov	r0, r3
 555 00e6 FFF7FEFF 		bl	motorSetPwmRight
 556              	.L27:
 557              	.LBE3:
 184:../Sources/drive/motor.c ****   }
 185:../Sources/drive/motor.c ****   return result;
 558              		.loc 1 185 0
 559 00ea FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 560              	.L30:
 186:../Sources/drive/motor.c **** }
 561              		.loc 1 186 0
 562 00ec 1846     		mov	r0, r3
 563 00ee 1037     		adds	r7, r7, #16
 564              		.cfi_def_cfa_offset 8
 565 00f0 BD46     		mov	sp, r7
 566              		.cfi_def_cfa_register 13
 567              		@ sp needed
 568 00f2 80BD     		pop	{r7, pc}
 569              	.L33:
 570              		.align	2
 571              	.L32:
 572 00f4 00000000 		.word	.LC0
 573 00f8 08000000 		.word	.LC1
 574 00fc 20000000 		.word	.LC2
 575 0100 28000000 		.word	.LC3
 576 0104 3C000000 		.word	.LC4
 577 0108 50000000 		.word	.LC5
 578 010c 5C000000 		.word	.LC6
 579 0110 1F85EB51 		.word	1374389535
 580 0114 64000000 		.word	.LC7
 581              		.cfi_endproc
 582              	.LFE129:
 584              		.section	.rodata
 585 0069 000000   		.align	2
 586              	.LC8:
 587 006c 286D6F74 		.ascii	"(motor)\000"
 587      6F722900 
 588              		.align	2
 589              	.LC9:
 590 0074 6D6F7400 		.ascii	"mot\000"
 591              		.section	.text.motorInit,"ax",%progbits
 592              		.align	1
 593              		.global	motorInit
 594              		.syntax unified
 595              		.thumb
 596              		.thumb_func
 597              		.fpu fpv4-sp-d16
 599              	motorInit:
 600              	.LFB130:
 187:../Sources/drive/motor.c **** 
 188:../Sources/drive/motor.c **** 
 189:../Sources/drive/motor.c **** 
 190:../Sources/drive/motor.c **** /**
 191:../Sources/drive/motor.c ****  * Initializes the motor driver:
 192:../Sources/drive/motor.c ****  * - Motor R A: PTD0, FTM3_CH0, Mux:4
 193:../Sources/drive/motor.c ****  * - Motor R B: PTE5, FTM3_CH0, Mux:6
 194:../Sources/drive/motor.c ****  * - Motor L A: PTD1, FTM3_CH1, Mux:4
 195:../Sources/drive/motor.c ****  * - motor L B: PTE6, FTM3_CH1, Mux:6
 196:../Sources/drive/motor.c ****  */
 197:../Sources/drive/motor.c **** void motorInit(void)
 198:../Sources/drive/motor.c **** {
 601              		.loc 1 198 0
 602              		.cfi_startproc
 603              		@ args = 0, pretend = 0, frame = 0
 604              		@ frame_needed = 1, uses_anonymous_args = 0
 605 0000 80B5     		push	{r7, lr}
 606              		.cfi_def_cfa_offset 8
 607              		.cfi_offset 7, -8
 608              		.cfi_offset 14, -4
 609 0002 00AF     		add	r7, sp, #0
 610              		.cfi_def_cfa_register 7
 199:../Sources/drive/motor.c ****   // todo #9.05 Configure the pin direction of the 4 pins as output.
 200:../Sources/drive/motor.c ****   GPIOD_PDDR |= 1<<0;
 611              		.loc 1 200 0
 612 0004 234A     		ldr	r2, .L35
 613 0006 234B     		ldr	r3, .L35
 614 0008 5B69     		ldr	r3, [r3, #20]
 615 000a 43F00103 		orr	r3, r3, #1
 616 000e 5361     		str	r3, [r2, #20]
 201:../Sources/drive/motor.c ****   GPIOE_PDDR |= 1<<5;
 617              		.loc 1 201 0
 618 0010 214A     		ldr	r2, .L35+4
 619 0012 214B     		ldr	r3, .L35+4
 620 0014 5B69     		ldr	r3, [r3, #20]
 621 0016 43F02003 		orr	r3, r3, #32
 622 001a 5361     		str	r3, [r2, #20]
 202:../Sources/drive/motor.c ****   GPIOD_PDDR |= 1<<1;
 623              		.loc 1 202 0
 624 001c 1D4A     		ldr	r2, .L35
 625 001e 1D4B     		ldr	r3, .L35
 626 0020 5B69     		ldr	r3, [r3, #20]
 627 0022 43F00203 		orr	r3, r3, #2
 628 0026 5361     		str	r3, [r2, #20]
 203:../Sources/drive/motor.c ****   GPIOE_PDDR |= 1<<6;
 629              		.loc 1 203 0
 630 0028 1B4A     		ldr	r2, .L35+4
 631 002a 1B4B     		ldr	r3, .L35+4
 632 002c 5B69     		ldr	r3, [r3, #20]
 633 002e 43F04003 		orr	r3, r3, #64
 634 0032 5361     		str	r3, [r2, #20]
 204:../Sources/drive/motor.c **** 
 205:../Sources/drive/motor.c **** 
 206:../Sources/drive/motor.c ****   // todo #9.06 set the pin value of all of the 4 pins to '1'
 207:../Sources/drive/motor.c ****   GPIOD_PDOR |= 1<<0 | 1<<1;
 635              		.loc 1 207 0
 636 0034 174A     		ldr	r2, .L35
 637 0036 174B     		ldr	r3, .L35
 638 0038 1B68     		ldr	r3, [r3]
 639 003a 43F00303 		orr	r3, r3, #3
 640 003e 1360     		str	r3, [r2]
 208:../Sources/drive/motor.c ****   GPIOE_PDOR |= 1<<5 | 1<<6;
 641              		.loc 1 208 0
 642 0040 154A     		ldr	r2, .L35+4
 643 0042 154B     		ldr	r3, .L35+4
 644 0044 1B68     		ldr	r3, [r3]
 645 0046 43F06003 		orr	r3, r3, #96
 646 004a 1360     		str	r3, [r2]
 209:../Sources/drive/motor.c **** 
 210:../Sources/drive/motor.c ****   // configures the pin muxing of all of the 4 pins as GPIO-Pin.
 211:../Sources/drive/motor.c ****   // the output level will be '1' because of the configuration above.
 212:../Sources/drive/motor.c ****   MOTOR_LEFT_A_GPIO();
 647              		.loc 1 212 0
 648 004c 134B     		ldr	r3, .L35+8
 649 004e 4FF48072 		mov	r2, #256
 650 0052 5A60     		str	r2, [r3, #4]
 213:../Sources/drive/motor.c ****   MOTOR_LEFT_B_GPIO();
 651              		.loc 1 213 0
 652 0054 124B     		ldr	r3, .L35+12
 653 0056 4FF48072 		mov	r2, #256
 654 005a 9A61     		str	r2, [r3, #24]
 214:../Sources/drive/motor.c ****   MOTOR_RIGHT_A_GPIO();
 655              		.loc 1 214 0
 656 005c 0F4B     		ldr	r3, .L35+8
 657 005e 4FF48072 		mov	r2, #256
 658 0062 1A60     		str	r2, [r3]
 215:../Sources/drive/motor.c ****   MOTOR_RIGHT_B_GPIO();
 659              		.loc 1 215 0
 660 0064 0E4B     		ldr	r3, .L35+12
 661 0066 4FF48072 		mov	r2, #256
 662 006a 5A61     		str	r2, [r3, #20]
 216:../Sources/drive/motor.c **** 
 217:../Sources/drive/motor.c ****   // todo #9.07 configure both channels as edge aligned PWM with low-true pulses
 218:../Sources/drive/motor.c ****   FTM3_C0SC |= FTM_CnSC_ELSA(1) | FTM_CnSC_MSB(1);
 663              		.loc 1 218 0
 664 006c 0D4A     		ldr	r2, .L35+16
 665 006e 0D4B     		ldr	r3, .L35+16
 666 0070 DB68     		ldr	r3, [r3, #12]
 667 0072 43F02403 		orr	r3, r3, #36
 668 0076 D360     		str	r3, [r2, #12]
 219:../Sources/drive/motor.c ****   FTM3_C1SC |= FTM_CnSC_ELSA(1) | FTM_CnSC_MSB(1);
 669              		.loc 1 219 0
 670 0078 0A4A     		ldr	r2, .L35+16
 671 007a 0A4B     		ldr	r3, .L35+16
 672 007c 5B69     		ldr	r3, [r3, #20]
 673 007e 43F02403 		orr	r3, r3, #36
 674 0082 5361     		str	r3, [r2, #20]
 220:../Sources/drive/motor.c **** 
 221:../Sources/drive/motor.c **** 
 222:../Sources/drive/motor.c ****   // register terminal command line handler
 223:../Sources/drive/motor.c ****   termRegisterCommandLineHandler(&clh, "mot", "(motor)", motorParseCommand);
 675              		.loc 1 223 0
 676 0084 084B     		ldr	r3, .L35+20
 677 0086 094A     		ldr	r2, .L35+24
 678 0088 0949     		ldr	r1, .L35+28
 679 008a 0A48     		ldr	r0, .L35+32
 680 008c FFF7FEFF 		bl	termRegisterCommandLineHandler
 224:../Sources/drive/motor.c **** }
 681              		.loc 1 224 0
 682 0090 00BF     		nop
 683 0092 80BD     		pop	{r7, pc}
 684              	.L36:
 685              		.align	2
 686              	.L35:
 687 0094 C0F00F40 		.word	1074786496
 688 0098 00F10F40 		.word	1074786560
 689 009c 00C00440 		.word	1074053120
 690 00a0 00D00440 		.word	1074057216
 691 00a4 00600240 		.word	1073897472
 692 00a8 00000000 		.word	motorParseCommand
 693 00ac 6C000000 		.word	.LC8
 694 00b0 74000000 		.word	.LC9
 695 00b4 00000000 		.word	clh
 696              		.cfi_endproc
 697              	.LFE130:
 699              		.text
 700              	.Letext0:
 701              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 702              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 703              		.file 4 "../Includes/core_cm4.h"
 704              		.file 5 "../Includes/system_MK22F51212.h"
 705              		.file 6 "../Includes/MK22F51212.h"
 706              		.file 7 "../Includes/platform.h"
 707              		.file 8 "../Sources/com/term.h"
 708              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\include
 709              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
 710              		.file 11 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\lib\\gcc\\arm-none-ea
 711              		.file 12 "c:\\program files (x86)\\gnu tools arm embedded\\6 2017-q2-update\\arm-none-eabi\\includ
DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:18     .bss.clh:00000000 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:21     .bss.clh:00000000 clh
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:26     .bss.valueRight:00000000 valueRight
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:27     .bss.valueRight:00000000 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:31     .bss.valueLeft:00000000 valueLeft
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:32     .bss.valueLeft:00000000 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:34     .text.motorIncrementPwmRight:00000000 $t
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:41     .text.motorIncrementPwmRight:00000000 motorIncrementPwmRight
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:176    .text.motorSetPwmRight:00000000 motorSetPwmRight
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:97     .text.motorIncrementPwmRight:00000044 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:102    .text.motorIncrementPwmLeft:00000000 $t
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:109    .text.motorIncrementPwmLeft:00000000 motorIncrementPwmLeft
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:285    .text.motorSetPwmLeft:00000000 motorSetPwmLeft
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:164    .text.motorIncrementPwmLeft:00000044 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:169    .text.motorSetPwmRight:00000000 $t
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:269    .text.motorSetPwmRight:00000088 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:278    .text.motorSetPwmLeft:00000000 $t
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:378    .text.motorSetPwmLeft:00000088 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:387    .rodata:00000000 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:412    .text.motorParseCommand:00000000 $t
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:419    .text.motorParseCommand:00000000 motorParseCommand
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:572    .text.motorParseCommand:000000f4 $d
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:592    .text.motorInit:00000000 $t
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:599    .text.motorInit:00000000 motorInit
C:\Users\jonas\AppData\Local\Temp\ccBDSLXG.s:687    .text.motorInit:00000094 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.a6d4f739a788c67292a3ea0a48d10bd5
                           .group:00000000 wm4.MK22F51212.h.96.792c303daa596f91c029224edd7c60aa
                           .group:00000000 wm4._newlib_version.h.4.3572908597b70d672d181fc7fc501c19
                           .group:00000000 wm4.features.h.33.cf97d4c9a045ebab6d282f6356e11363
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.cce27fed8484c08a33f522034c30d2b5
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.MK22F51212.h.109.eeee73bf5f54e3f06177795004b95e22
                           .group:00000000 wm4.core_cm4.h.43.f75e2f71b2e33f7a3db429cd8b0cae9e
                           .group:00000000 wm4.core_cmInstr.h.39.addda81f1f3453ba31dd54fc5b6fcee8
                           .group:00000000 wm4.core_cmSimd.h.43.c355993beb49ccd10586af5b1cfe5aee
                           .group:00000000 wm4.core_cm4.h.201.a59e218d30e39d114c8962bbad645c74
                           .group:00000000 wm4.system_MK22F51212.h.94.09b5fd63c227fb82ca8c370fba9e2334
                           .group:00000000 wm4.MK22F51212.h.369.5a9c5aa32d240e03ff494f1c769cfadf
                           .group:00000000 wm4.platform.h.20.5dba9aa78ee93a87b4214fc940da3bb4
                           .group:00000000 wm4.motor.h.17.cf02e8017a4c3f5c3495abf75603565e
                           .group:00000000 wm4.ftm3.h.17.18543e90097720d6aa4aa53f58670c33
                           .group:00000000 wm4.stddef.h.39.99b5021e28f91cdb161c889e07266673
                           .group:00000000 wm4.newlib.h.8.5f2124c7e712be65f83b91ff86a0b1c1
                           .group:00000000 wm4.config.h.219.65a553ab5bef5482f0d7880b0d33015e
                           .group:00000000 wm4._ansi.h.23.9f8fcfa20193763fcf364fb91705c94b
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4._types.h.125.5cf8a495f1f7ef36777ad868a1e32068
                           .group:00000000 wm4.stddef.h.161.5349cb105733e8777bfb0cf53c4e3f34
                           .group:00000000 wm4._types.h.183.c226d164ceca1f2ecb9ae9360c54a098
                           .group:00000000 wm4.reent.h.17.23b059516345f8f5abfa01ddc379570f
                           .group:00000000 wm4.cdefs.h.47.776a25dae4205bae6cce27d545bc475b
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.161.19e15733342b50ead2919490b095303e

UNDEFINED SYMBOLS
strcmp
termWriteLine
strncmp
utilScanDecimal16s
termRegisterCommandLineHandler
